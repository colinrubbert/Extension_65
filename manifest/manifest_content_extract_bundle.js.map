{"version":3,"sources":["manifest_content_extract_bundle.js"],"names":["globals","_forCopySelectInput","input","tagName","toLowerCase","range","document","createRange","selectNodeContents","sel","window","getSelection","removeAllRanges","addRange","select","_copyToClipboard","val","isHtml","copy","hideStyle","createElement","contentEditable","innerHTML","setAttribute","body","appendChild","focus","value","execCommand","_forCopyInput","test","remove","RELAY","on","data","IRX","UI","$","PageFeatureBaseClass","EventableClass","_featureName","_configTemplate","_mutationObserver","_initialized","_eventsBound","_wasApiTimeout","_apiTmo","_uiCheckInterval","_uiImpressionIdBlocklist","constructor","featureName","debug","uiCheckInterval","configTemplate","super","levels","content","this","log","hasUi","lastApiCallFailed","_shouldInitialize","shouldBindEvents","markUiButtonClick","componentId","componentName","site","sitePage","surface","refId","action","featureEvent","markUiImpression","setTimeout","length","includes","logNoStore","push","index","indexOf","splice","cleanup","cleanupListeners","_clearApiCallTimer","_cleanupUi","_cleanupMessageListeners","disconnect","_init","Error","_bindEvents","_bindMessageListeners","_uiChange","reset","MutationObserver","UTILS","debounce","bind","observe","getElementsByTagName","attributes","childList","subtree","getElementById","append","_setApiCallTimer","apiTimeout","clearTimeout","IS_DEV","console","error","_error","_notification","notifications","notification","errors","GENERIC_ERROR_MESSAGE","PAGE_EXTRACT_MANIFEST_DEPENDENCIES","_pageAdvertiserKey","_pageScriptsInjected","EXTRACT_TYPES","Object","freeze","hosted","resume","EXTRACT_PAGES","candidateViewPage","employerCandidateList","individualResume","projectPage","Extract","advertiserKey","toConnectedSystem","xcom","startExtract","showPostExtract","batchId","CONTENT_UTILS","bindChromeEventListener","chrome","runtime","onMessage","offAll","unbindChromeEventListener","async","msg","Promise","resolve","doXcom","buildXcomMeta","url","metadata","failureMessage","XcomShim","setup","done","close","e","toString","pageExtractInfo","determineExtractPageType","location","href","type","page","subsource","info","isHosted","CT","extract","resumeKey","pathname","split","pop","genericError","interested","interestedSel","fullName","fullNameSel","text","saveIndividualClip","indeed_resume_account_key","full_name","individual","fullnameSel","projectKey","filter","v","project_key","advertiser_key","candidateKey","getQueryParam","hash","indeed_hosted_candidate_key","jobKey","isAllOpenPausedInUi","openAndPausedSel","hosted_job_id","status_name","obj","meta","assign","pushDirectlyToIntegrations","extensionManifestVersion","clipData","loading","send","iframe","static","origin","loadScriptDependencies","reject","loadPageScripts","relayOnOnceAwait","supportInfo","iframe_shim","types","pages","TEMPLATES","SELECTOR_ID","EXTRACT","PageButtons","wasIndividualResume","integrations","reminders","cloneObject","connectedSystemInfo","response","show","disabled","label","lastPausedAt","determinePageSupport","insertFn","wrapSel","buttonStyle","updateFn","forceRedraw","testFn","customCssRule","isResume","buttons","style","$wrap","html","nextAll","find","before","replace","selectorSel","testInterestedFnSel","list","parentSel","closest","parentClosestSel","addClass","customParentClass","customParentRule","filterParam","fromParam","startsWith","buttonInfo","$existing","wasExisting","csInfo","addCustomCssStyleToPage","buttonId","Date","now","templateData","pushLabel","showApiButton","id","build","drawReminder","reminderKey","modal","localSend","keys","isOrphaned","stopImmediatePropagation","target","cssRule","sheet","insertRule","LoggableClass","errored","errorCb","doneCb","getTime","addIdAndDataParams","setupRelay","urlParts","params","URLSearchParams","JSON","stringify","onOnce","teardown","classList","add","fullpageUi","isDone","state","STATE","ContentState","pageButtons","onOrphaned","onUserChange","loggedIn","userInfo","pageAdvertiserKey","advertisersMatch","getCurrentPageAdvertiserKey","configTemplates","get"],"mappings":"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","file":"manifest_content_extract_bundle.js","sourcesContent":["/* globals IRX */\n\n(async (globals) => {\n\n    let _forCopySelectInput = (input) => {\n        if (input.tagName.toLowerCase() == 'div') {\n            let range = document.createRange();\n            range.selectNodeContents(input);\n            let sel = window.getSelection();\n            sel.removeAllRanges();\n            sel.addRange(range);\n        } else {\n            input.select();\n        }\n    };\n\n    let _forCopyInput = (isHtml, val = null, copy = false) => {\n        let hideStyle = 'width:0; height: 0; overflow: hidden;',\n            input;\n        if (isHtml) {\n            input = document.createElement('div');\n            input.contentEditable = true;\n            input.innerHTML = val;\n            input.setAttribute('style', hideStyle);\n            document.body.appendChild(input);\n            input.focus();\n            _forCopySelectInput(input);\n        } else {\n            input = document.createElement('textarea');\n            input.setAttribute('style', hideStyle);\n            input.value = val;\n            document.body.appendChild(input);\n            input.focus();\n            _forCopySelectInput(input);\n        }\n        if (copy) {\n            document.execCommand('copy');\n        } else {\n            document.execCommand('paste');\n        }\n        return input;\n    };\n\n    function _copyToClipboard(val) {\n        let isHtml = (/<br[\\/]?>|<p>|<span>|<b>|<i>/i).test(val);\n        let input = _forCopyInput(isHtml, val, true); // copy val to clipboard\n        input.remove();\n    }\n\n    globals.RELAY.on('copy.clipboard', data => {\n        _copyToClipboard(data.value);\n    });\n\n})(IRX);\n\n/* globals IRX, EventableClass */\n\n(async (globals) => {\n\n    const UI_IMPRESSION_THRESHOLD_MS = 1000;\n    const DEBOUNCE_UI_IMPRESSION_EVENT_MS = 15 * 1000;\n    const UI = globals.UI;\n    const API_TIMEOUT_MS = 1000 * 10; // 10 second timeout for calling an API\n    const $ = globals.$;\n\n    class PageFeatureBaseClass extends EventableClass{\n        _featureName;\n        _configTemplate;\n        _mutationObserver;\n        _initialized = false;\n        _eventsBound = false;\n        _wasApiTimeout = false;\n        _apiTmo;\n        _uiCheckInterval;\n        _uiImpressionIdBlocklist = [];\n\n        constructor(featureName, debug, uiCheckInterval = null, configTemplate=null, ){\n            super(debug, EventableClass.levels.content);\n\n            // NOTE -- if there are no on-page UI elems, and mutationObserver is not needed, pass in\n            // null for uiCheckInterval\n\n            this._featureName = featureName;\n            this._configTemplate = configTemplate;\n            this._uiCheckInterval = uiCheckInterval;\n            this.log(`Page feature component setup, has UI? ${this.hasUi}`);\n        }\n\n        get hasUi(){\n            return this._uiCheckInterval !== null;\n        }\n\n        get lastApiCallFailed(){\n            return this._wasApiTimeout;\n        }\n\n        get _shouldInitialize(){\n            if (!this._initialized) {\n                this._initialized = true;\n                this.log('Running init');\n                return true;\n            }\n            return false;\n        }\n\n        get #shouldBindEvents(){\n            if(!this.hasUi) return false;\n            if (!this._eventsBound) {\n                this._eventsBound = true;\n                this.log('Binding events');\n                return true;\n            }\n            return false;\n        }\n\n        markUiButtonClick(componentId, componentName, site, sitePage, surface=null, refId=null){\n            // NOTE -- we are currently logging repeat button clicks. If we want to change this behavior, we can\n            // leverage tracking by componentId\n            const action = `${componentName}_button_clicked`;\n            this.featureEvent(this._featureName, action, site, sitePage, surface, refId);\n        }\n\n        markUiImpression(componentId, componentName, site, sitePage=null, surface=null, refId=null ){\n            // NOTE -- we only mark impressiosn for the exact same componentID every <DEBOUNCE_UI_IMPRESSION_EVENT_SECONDS> seconds\n            // to mitigate redraws and somewhat realistic user behavior/experience\n\n            const action = `${componentName}_impression`;\n\n            setTimeout(() => {\n                let $el = $(`[data-irx-id=\"${componentId}\"]`);\n                if (!$el.length) return;\n\n                if(this._uiImpressionIdBlocklist.includes(componentId)){\n                    return this.logNoStore('No impression track for ID, still in blocklist.');\n                }\n                this._uiImpressionIdBlocklist.push(componentId);\n\n                setTimeout(() => {\n                    const index = this._uiImpressionIdBlocklist.indexOf(componentId);\n                    if(index !== -1) this._uiImpressionIdBlocklist.splice(index, 1);\n                }, DEBOUNCE_UI_IMPRESSION_EVENT_MS);\n\n                this.log('Marking UI impression for component!', componentName, componentId);\n                this.featureEvent(this._featureName, action, site, sitePage);\n            }, UI_IMPRESSION_THRESHOLD_MS);\n        }\n\n        cleanup(cleanupListeners=true){\n            this._clearApiCallTimer();\n            this._cleanupUi();\n            if(cleanupListeners) this._cleanupMessageListeners();\n            if (this.hasUi && this._mutationObserver) this._mutationObserver.disconnect();\n        }\n\n        _init(){\n            // function to initialize the class and any listeners, etc, NOTE it must check this._shouldInitialize() before running\n            throw new Error('Class must implement _init');\n        }\n\n        _bindEvents(){\n            // function to call to bind any event listeners.\n            // You can assume this is only ever called once on init (don't call in child class) and should be ONLY for\n            // DOM-based listeners\n            throw new Error('Class must implement _bindEvents');\n        }\n\n        _bindMessageListeners(){\n            // function to call RELAY and native message listeners\n            // this is called on EACH reset, and if using you should also override _cleanupMessageListeners\n        }\n\n        _cleanupUi(){\n            if(!this.hasUi) return;\n            // function called to remove/cleanup any UI on the page that we added\n            throw new Error('Class must implement _cleanupUi');\n        }\n\n        _cleanupMessageListeners(){\n            // optional to override if needed (see _bindMessageListeners)\n        }\n\n        _uiChange(){\n            if(!this.hasUi) return;\n            // function called whenever something in the UI has changed (or page navigation, etc)\n            throw new Error('Class must implement _uiChange');\n        }\n\n        reset() {\n            this.cleanup(false);\n            if (!this._initialized) return;\n            this.log('Reset called');\n\n            // bindEvents is for DOM based event listers that should be setup ONCE\n            if(this.#shouldBindEvents) this._bindEvents();\n\n            this._bindMessageListeners(); // bind RELAY and native message listeners\n\n            if(this.hasUi) {\n                this.log('Setting up mutationObserver');\n                this._mutationObserver = new MutationObserver(globals.UTILS.debounce(this._uiChange.bind(this), this._uiCheckInterval));\n                this._mutationObserver.observe(document.getElementsByTagName('body')[0], {\n                    attributes: false, childList: true, subtree: true\n                });\n\n                this._uiChange();\n            }\n\n            if(!document.getElementById('irxGoogleFont')) {\n                // append needed info to head for NOTO-SANS font\n                $('head').append('<link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" id=\"irxGoogleFont\">')\n                    .append('<link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossOrigin>')\n                    .append('<link href=\"https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap\" rel=\"stylesheet\">');\n            }\n        }\n\n        _setApiCallTimer(){\n            this._wasApiTimeout = false;\n            this._apiTmo = setTimeout(this.#apiTimeout.bind(this), API_TIMEOUT_MS);\n        }\n\n        _clearApiCallTimer(){\n            clearTimeout(this._apiTmo);\n        }\n\n        #apiTimeout() {\n            this._wasApiTimeout = true;\n            if(globals.IS_DEV) console.error('API Timeout!');\n            this.log(`Error occurred calling API, timeout after ${API_TIMEOUT_MS} ms`);\n            this._error('An error occured. Please contact support if the issue persists');\n        }\n\n        _notification(notifications) {\n            this.log('NOTIFICATIONS', notifications);\n            UI.notification(notifications);\n        }\n\n        _error(errors) {\n            this.log('ERRORS', errors);\n            UI.error(errors);\n        }\n\n    }\n    globals.PageFeatureBaseClass = PageFeatureBaseClass;\n\n})(IRX);\n\n/* globals PageFeatureBaseClass, IRX */\n\n(async (globals) => {\n\n    const RELAY = globals.RELAY;\n    const UI = globals.UI;\n    const GENERIC_ERROR_MESSAGE = 'There was an issue loading the needed extraction information. Please try again.';\n    const PAGE_EXTRACT_MANIFEST_DEPENDENCIES = ['page_primary_bundle', 'page_extract_bundle'];\n    const $ = globals.$;\n\n    let _pageAdvertiserKey;\n    let _pageScriptsInjected;\n\n    // TODO -- make these dynamically generated from content_script_definitions.json if possible\n    const EXTRACT_TYPES = Object.freeze({ hosted: 'hosted', resume: 'resume' });\n    const EXTRACT_PAGES = Object.freeze({\n        candidateViewPage: 'candidateViewPage',\n        employerCandidateList: 'employerCandidateList',\n        individualResume: 'individualResume',\n        projectPage: 'projectPage'\n    });\n\n    class Extract extends PageFeatureBaseClass {\n        #advertiserKey;\n        #toConnectedSystem = false;\n        #xcom;\n\n        constructor(advertiserKey, configTemplate) {\n            super('extract', false, null, configTemplate);\n            this.#advertiserKey = advertiserKey;\n            this._init();\n        }\n\n        _bindMessageListeners(){\n            RELAY.on('start.extract', this.#startExtract.bind(this));\n            RELAY.on('clipSaved.extract', data => {\n                this._clearApiCallTimer();\n                this.#showPostExtract(data.batchId);\n            });\n            RELAY.on('errors.extract', data => {\n                this._clearApiCallTimer();\n                this._error(data.errors);\n            });\n\n            // NOTE -- maybe this flow of binding onMessage can get moved to pageFeatureBaseClass ??\n            globals.CONTENT_UTILS.bindChromeEventListener(chrome.runtime.onMessage, this.#onMessage, this);\n        }\n\n        _cleanupMessageListeners(){\n            RELAY.offAll('extract');\n            // NOTE -- maybe this flow of binding onMessage can get moved to pageFeatureBaseClass ??\n            globals.CONTENT_UTILS.unbindChromeEventListener(chrome.runtime.onMessage, this.#onMessage);\n        }\n\n        _init(){\n            if(!this._shouldInitialize) return;\n            this.reset();\n        }\n\n        async #onMessage(msg){\n            if(msg === 'popup.extract'){\n                this.#startExtract({toConnectedSystem: false});\n                return Promise.resolve();\n            }\n        }\n\n        #showPostExtract(batchId){\n            this.log('Show post extract', batchId);\n            // NOTE this is only called after single-record extract, it's redirected to in dashboard for multi record\n            const failureMessage = 'Your record was extracted but there was an error displaying it. Please view it in your IRX clipboard.';\n            this.#doXcom(`/hosted-jobs-extract/iframe-modal/post-extract/batch/${batchId}`, this.#buildXcomMeta(), failureMessage);\n        }\n\n        async #doXcom(url, metadata, failureMessage=GENERIC_ERROR_MESSAGE){\n            this.#xcom = new globals.XcomShim(url, metadata);\n\n            await this.#xcom.setup();\n\n            try {\n                await this.#xcom.done();\n                UI.close();\n            } catch(e) {\n                console.error(e);\n                this.log('Error creating/comming with xcom!', e.toString());\n                UI.error(failureMessage);\n            }\n            this.#xcom = null;\n        }\n\n        async #startExtract(data){\n            const {toConnectedSystem} = data;\n            this.#toConnectedSystem = toConnectedSystem;\n\n            let pageExtractInfo;\n            try{\n                pageExtractInfo = await this.constructor.determineExtractPageType(window.location.href);\n                if(!pageExtractInfo) throw new Error('Empty pageExtractInfo');\n            }catch(e){\n                this.log('Unale to get pageExtractInfo', e);\n                return UI.error(GENERIC_ERROR_MESSAGE);\n            }\n\n            const {type, page, subsource} = pageExtractInfo.info;\n            const isHosted = type === EXTRACT_TYPES.hosted;\n            const isResume = type === EXTRACT_TYPES.resume;\n\n            if(isResume){\n                const CT = this._configTemplate.extract.resume;\n\n                if(page === EXTRACT_PAGES.individualResume){\n                    this.log('Individual resume page detected.');\n                    const resumeKey = window.location.pathname.split('/').pop();\n                    this.log('Resume key from URL', resumeKey);\n                    if(!resumeKey){\n                        this.log('Error extracting resumeKey from url!');\n                        return UI.genericError();\n                    }\n\n                    const interested = !!$(CT.individualResume.interestedSel).length;\n\n                    this.log('Contact is interested?', interested);\n                    if(!interested) return UI.error('Only interested contacts can be extracted.');\n\n                    const fullName = $(CT.individualResume.fullNameSel).text();\n                    return this.#saveIndividualClip(subsource, {\n                        indeed_resume_account_key: resumeKey,\n                        full_name: fullName\n                    });\n                    \n                }else if(page === EXTRACT_PAGES.projectPage){\n\n                    // determine if we have an individual resume open on the project page or are just looking at the list\n                    if(window.location.pathname.includes('/jobseekers/')){\n                        this.log('Resume projects page, individual resume view');\n                        const resumeKey = window.location.pathname.split('/jobseekers/').pop();\n                        this.log('Resume account key from URL', resumeKey);\n                        if(!resumeKey){\n                            this.log('Error extracting resumeKey from url!');\n                            return UI.genericError();\n                        }\n\n                        const interested = !!$(CT.projectPage.individual.interestedSel).length;\n                        this.log('Contact is interested?', interested);\n                        if(!interested) return UI.error('Only interested contacts can be extracted.');\n\n                        const fullName = $(CT.projectPage.individual.fullnameSel).text();\n                        return this.#saveIndividualClip(subsource, {\n                            indeed_resume_account_key: resumeKey,\n                            full_name: fullName\n                        });\n                    }\n\n                    this.log('Resume projects page, list view');\n\n                    const projectKey = window.location.pathname.split('/').filter(v => !!v).pop();\n                    this.log('Project key from URL', projectKey);\n                    if(!projectKey){\n                        this.log('Error detecting project key from URL!');\n                        return UI.genericError();\n                    }\n\n                    const url = '/resume-extract/iframe-modal/form';\n                    const metadata = {\n                        project_key: projectKey,\n                        advertiser_key: this.#advertiserKey\n                    };\n                    this.#doXcom(url, this.#buildXcomMeta(metadata));\n                }\n\n            }else if(isHosted){\n                if(page === EXTRACT_PAGES.candidateViewPage) {\n                    this.log('Hosted candidate view individual page detected');\n                    const candidateKey = globals.UTILS.getQueryParam('id') || globals.UTILS.getQueryParam('id', window.location.hash);\n                    if(!candidateKey){\n                        this.log('Error detecting candidate key from URL!');\n                        return UI.genericError();\n                    }\n\n                    return this.#saveIndividualClip(subsource, {\n                        indeed_hosted_candidate_key: candidateKey\n                    });\n                }else if(page === EXTRACT_PAGES.employerCandidateList) {\n                    this.log('Hosted candidate list page');\n                    let jobKey = globals.UTILS.getQueryParam('id') || globals.UTILS.getQueryParam('id', window.location.hash);\n\n                    // There's a weird edge case where if you're on a specific job ID, then switch advertiser it defaults the UI view to\n                    // all open/paused but the old jobId is still in the query params, which breaks the extraction. This double checks to\n                    // see if we think this is a specific job, that the UI is *not* on all open/paused\n                    const isAllOpenPausedInUi = $(this._configTemplate.extract.hosted.openAndPausedSel).length !== 0;\n                    this.log('Job key from URL', jobKey);\n                    this.logNoStore('Is open paused in UI?', isAllOpenPausedInUi);\n                    if(isAllOpenPausedInUi && jobKey !== '0'){\n                        // EDGE CASE -- fix it so it's all open/paused\n                        jobKey = '0';\n                        this.log('Edge case detected, switching to all open/paused job key!');\n                    }\n\n                    if(!jobKey){\n                        this.log('Error detecting job key from URL!');\n                        return UI.genericError();\n                    }\n\n                    const url = '/hosted-jobs-extract/iframe-modal/form';\n                    const metadata = {\n                        hosted_job_id: jobKey,\n                        advertiser_key: this.#advertiserKey,\n                        status_name: globals.UTILS.getQueryParam('statusName'),\n                    };\n                    this.#doXcom(url, this.#buildXcomMeta(metadata));\n                }\n            }\n        }\n\n        #buildXcomMeta(obj = {}){\n            let meta = {};\n            Object.assign(meta, obj);\n            Object.assign(meta, {\n                pushDirectlyToIntegrations: this.#toConnectedSystem,\n                extensionManifestVersion: 3\n            });\n            return meta;\n        }\n\n        #saveIndividualClip(subsource, data){\n            const clipData = {\n                subsource,\n                data\n            };\n            this.logNoStore('Generated clip data', clipData);\n\n            UI.loading('Saving record.');\n            this._setApiCallTimer();\n\n            RELAY.send('saveClip.extract', RELAY.levels.iframe, {clipData});\n        }\n\n        static async #loadPageScripts(){\n            if (!_pageScriptsInjected) {\n                const origin = '//@EXTENSION_URL//';\n                await globals.UTILS.loadScriptDependencies(origin, PAGE_EXTRACT_MANIFEST_DEPENDENCIES);\n                _pageScriptsInjected = true;\n            }\n        }\n\n        static getCurrentPageAdvertiserKey(){\n            return new Promise(async (resolve, reject) => {\n                try {\n                    await this.#loadPageScripts();\n\n                    _pageAdvertiserKey = _pageAdvertiserKey || (await globals.UTILS.relayOnOnceAwait(\n                        'requestAdvertiserKey.extract', RELAY.levels.page, null,\n                        'returnAdvertiserKey.extract'\n                    )).advertiserKey;\n\n                    if (!_pageAdvertiserKey) throw new Error('Empty _pageAdvertiserKey');\n                }catch(e){\n                    return reject(e);\n                }\n\n                resolve(_pageAdvertiserKey);\n            });\n        }\n\n        static determineExtractPageType(url) {\n            return new Promise(async (resolve, reject) => {\n                let supportInfo;\n\n                try {\n                    supportInfo = await globals.UTILS.relayOnOnceAwait(\n                        'requestInfoForPage.extract', RELAY.levels.iframe_shim, {url},\n                        'returnInfoForPage.extract');\n\n                    if(!supportInfo) throw new Error('Empty supportInfo');\n\n                }catch(e){\n                    return reject(e);\n                }\n                resolve(supportInfo);\n            });\n        }\n\n        static get types() {\n            return EXTRACT_TYPES;\n        }\n\n        static get pages() {\n            return EXTRACT_PAGES;\n        }\n    }\n\n    globals.Extract = Extract;\n\n})(IRX);\n\n/* globals IRX, PageFeatureBaseClass */\n\n(async (globals) => {\n\n    const TEMPLATES = globals.TEMPLATES;\n    const SELECTOR_ID = 'irx_inline_extract_button';\n    const API_PUSH_BTN_ID = 'irx_connected_push_extract_button';\n    const EXTRACT_BTN_ID = 'irx_inline_extract_btn';\n    const CUSTOM_STYLE_ELEM_ID = 'irx_button_custom_style_rule';\n    const EXTRACT = globals.Extract;\n    const UI_DRAW_CHECK_INTERVAL = 500; // 500 ms debounce for mutationObserver checks\n    const $ = globals.$;\n\n    class PageButtons extends PageFeatureBaseClass {\n        #pageExtractInfo;\n        #wasIndividualResume = false;\n        #integrations = [];\n        #reminders = [];\n\n        constructor(integrations, reminders, configTemplate) {\n            super('extract_button', false, UI_DRAW_CHECK_INTERVAL, configTemplate);\n            this.logNoStore('initialized with reminders', globals.UTILS.cloneObject(reminders));\n            this._init(integrations, reminders);\n        }\n\n        get connectedSystemInfo() {\n            let response = {show: false, disabled: false, label: 'Connected Systems'};\n            if (!this.#integrations.length) return response;\n            response.show = true;\n\n            if (this.#integrations.length === 1) {\n                if (this.#integrations[0].lastPausedAt) {\n                    response.label = this.#integrations[0].label + ' (Paused) ';\n                    response.disabled = true;\n                } else {\n                    response.label = 'Push to ' + this.#integrations[0].label;\n                }\n            }\n            return response;\n        }\n\n        #determinePageSupport(){\n            return new Promise(async (resolve) => {\n                let info = {\n                    insertFn: null,\n                    wrapSel: null,          // selector for wrap to insert button group into\n                    buttonStyle: '',        // extra css class to apply to the button group\n                    updateFn: null,         // optional fn that takes in $wrap to do stuff with after draw\n                    forceRedraw: false,\n                    testFn: null,\n                    customCssRule: null\n                };\n\n                const pageExtractInfo = await EXTRACT.determineExtractPageType(window.location.href);\n                this.#pageExtractInfo = pageExtractInfo;\n                this.log('pageExtractInfo', pageExtractInfo);\n\n                if(!pageExtractInfo || !pageExtractInfo.info) return resolve(null);\n\n                const {type, page} = pageExtractInfo.info;\n                const isHosted = type === EXTRACT.types.hosted;\n                const isResume = type === EXTRACT.types.resume;\n                \n                const CT = this._configTemplate.buttons;\n\n                if(isHosted){\n                    if(page === EXTRACT.pages.candidateViewPage){\n                        // candidate individual view page in hosted jobs\n                        info.wrapSel = CT.hosted.candidateViewPage.wrapSel;\n                        info.buttonStyle = CT.hosted.candidateViewPage.style;\n\n                    }else if(page === EXTRACT.pages.employerCandidateList) {\n                        // New OneHost UI for hosted jobs candidate list\n                        info.wrapSel = CT.hosted.employerCandidateList.wrapSel;\n                        info.buttonStyle = CT.hosted.employerCandidateList.style;\n                        info.insertFn = ($wrap, html) => {\n                            $wrap.nextAll(CT.hosted.employerCandidateList.insertFn.nextAll)\n                                .find(CT.hosted.employerCandidateList.insertFn.find)\n                                .before(CT.hosted.employerCandidateList.insertFn.before.replace('{{HTML}}', html));\n                        };\n                    }\n                }\n\n                if(isResume){\n                    if(page === EXTRACT.pages.individualResume){\n                        info.wrapSel = 'todo';\n                        info.buttonStyle = 'todo';\n\n                    }else if(page === EXTRACT.pages.projectPage){\n                        // projects 'interested' or 'email response' views\n\n                        // CT.projectPage.individual.selectorSel\n                        if ($(CT.projectPage.individual.selectorSel).length) {\n                            // individual resume shown\n                            if(!this.#wasIndividualResume) info.forceRedraw = true;\n                            this.#wasIndividualResume = true;\n\n                            // CT.projectPage.individual.wrapSel\n                            info.wrapSel = CT.projectPage.individual.wrapSel;\n                            info.buttonStyle = CT.projectPage.individual.style;\n                            info.testFn = () => {\n                                return $(CT.projectPage.individual.testInterestedFnSel).length;\n                            };\n                        }else{\n                            this.#wasIndividualResume = false;\n                            info.wrapSel = CT.projectPage.list.wrapSel;\n                            info.buttonStyle = CT.projectPage.list.style;\n                            $(CT.projectPage.list.parentSel).closest(CT.projectPage.list.parentClosestSel).addClass(CT.projectPage.list.customParentClass);\n                            info.customCssRule = CT.projectPage.list.customParentRule;\n                            info.testFn = () => {\n                                const filterParam = globals.UTILS.getQueryParam('filter') || '';\n                                const fromParam = globals.UTILS.getQueryParam('from') || '';\n                                return ['interested','replied'].includes(filterParam) || fromParam.startsWith('interested.email');\n                            };\n                        }\n                    }\n                }\n\n                resolve(info);\n            });\n        }\n\n        async _uiChange() {\n            this.log('uiChange');\n            //if (data_loaded && !force) return;\n\n            const buttonInfo = await this.#determinePageSupport();\n            this.logNoStore('button info result', buttonInfo);\n\n\n            const $existing = $(`#${SELECTOR_ID}`);\n            const wasExisting = $existing.length;\n            if(!buttonInfo){\n                if($existing.length) this._cleanupUi();\n                return this.logNoStore('Removing existing button and returning.');\n            }\n\n            if(buttonInfo.testFn && !buttonInfo.testFn()){\n                if($existing.length) this._cleanupUi();\n                return this.log('No draw, did not pass test function');\n            }\n\n            if($existing.length){\n                if(buttonInfo.forceRedraw){\n                    this._cleanupUi();\n                }else{\n                    return this.logNoStore('Button exists, not drawing again');\n                }\n            }\n\n            if(!$(buttonInfo.wrapSel).length){\n                return this.log('No draw, wrapSel missing!');\n            }\n\n            const csInfo = this.connectedSystemInfo;\n\n            if(buttonInfo.customCssRule){\n                this.#addCustomCssStyleToPage(buttonInfo.customCssRule);\n            }\n\n            const buttonId = Date.now();\n            const templateData = {\n                buttonId,\n                pushLabel: csInfo.label,\n                showApiButton: csInfo.show,\n                id: SELECTOR_ID,\n                buttonStyle: buttonInfo.buttonStyle,\n                disabled: csInfo.disabled\n            };\n\n            const html = await TEMPLATES.build('extract_button', templateData);\n            this.logNoStore('Add HTML', html);\n\n            // Verify wrap is still there\n            const $wrap = $(buttonInfo.wrapSel);\n            if (!$wrap.length) return this.logNoStore('Wrap missing after template generation, not inserting button');\n            if(buttonInfo.insertFn){\n                buttonInfo.insertFn($wrap, html);\n            }else {\n                $wrap.append(html);\n            }\n            if (buttonInfo.updateFn) buttonInfo.updateFn($wrap);\n            this.#drawReminder();\n\n            if(!wasExisting){\n                const {type, page} = this.#pageExtractInfo.info;\n                this.markUiImpression(buttonId, 'create_button', 'indeed', type, page);\n            }\n        }\n\n        async #drawReminder(){\n            const {type, page} = this.#pageExtractInfo.info;\n\n            const reminderKey = `${type}_${page}`;\n            this.log('Checking reminder key to draw reminder for', reminderKey, this.#reminders[reminderKey]);\n            if(this.#reminders[reminderKey]) return this.log('not showing reminder, already seen');\n\n            const html = await TEMPLATES.build('extract_getting_started');\n            globals.UI.modal(html);\n\n            this.#reminders[reminderKey] = true;\n            globals.RELAY.localSend('markReminderSeen.state', {keys: [reminderKey]});\n        }\n\n        _cleanupUi(){\n            const $existing = $('#' + SELECTOR_ID);\n            if ($existing.length) $existing.remove();\n        }\n        \n        _init(integrations, reminders){\n            if(!this._shouldInitialize) return;\n            this.reset(integrations, reminders);\n        }\n\n        reset(integrations, reminders){\n            this.#integrations = integrations || [];\n            this.#reminders = reminders;\n            super.reset();\n        }\n\n        #startExtract(buttonId, toConnectedSystem=false){\n            this.log(`Initialize extract - (for connected system push? ${toConnectedSystem ? 'true' : 'false'})`);\n            const {type, page} = this.#pageExtractInfo.info;\n            this.markUiButtonClick(buttonId, 'extract', 'indeed', type, page);\n            globals.RELAY.localSend('start.extract', {toConnectedSystem});\n        }\n\n        _bindEvents(){\n            $(document.body).on('click.irx', `#${SELECTOR_ID} #${EXTRACT_BTN_ID}`, (e) => {\n                if(globals.CONTENT_UTILS.isOrphaned) return;\n                e.stopImmediatePropagation();\n                const buttonId = $(e.target).data('irx-id');\n                this.#startExtract(buttonId);\n            }).on('click.irx', `#${SELECTOR_ID} #${API_PUSH_BTN_ID}`, (e) => {\n                if(globals.CONTENT_UTILS.isOrphaned) return;\n                e.stopImmediatePropagation();\n                const buttonId = $(e.target).data('irx-id');\n                this.#startExtract(buttonId,true);\n            });\n        }\n\n        #addCustomCssStyleToPage(cssRule){\n            const oldElem = document.getElementById(CUSTOM_STYLE_ELEM_ID);\n            oldElem?.remove();\n\n            let style = document.createElement('style');\n            style.setAttribute('id', CUSTOM_STYLE_ELEM_ID);\n            document.getElementsByTagName('head')[0].appendChild(style);\n            style.sheet.insertRule(cssRule);\n        }\n\n    }\n\n    globals.PageButtons = PageButtons;\n\n})(IRX);\n\n/* globals IRX, LoggableClass */\n\n((globals) => {\n\n    const TEMPLATES = globals.TEMPLATES;\n    const UI = globals.UI;\n    const RELAY = globals.RELAY;\n\n    const BODY_NOSCROLL_CLASS = 'irx_noscroll';\n\n    class XcomShim  extends LoggableClass {\n        #id;\n        #metadata;\n        #url;\n        #errored = false;\n        #errorCb;\n        #doneCb;\n\n        constructor(url, metadata){\n            super(false);\n            this.#id = (new Date().getTime());\n            this.#metadata = metadata;\n            this.#url = this.#addIdAndDataParams(url);\n\n            this.#setupRelay();\n        }\n\n        #addIdAndDataParams(url){\n            let urlParts = url.split('?', 2);\n            let params = new URLSearchParams(urlParts.length > 1 ? urlParts.pop() : '');\n            params.append('xcomId', this.#id);\n            params.append('data', JSON.stringify(this.#metadata));\n            return urlParts + '?' + params.toString();\n        }\n\n        #setupRelay(){\n            RELAY.onOnce('exit.xcomShim', () => {\n                this.log('exit.xcomShim');\n                this.teardown();\n            });\n            RELAY.on('error.xcomShim', (data) => {\n                this.#errored = true;\n                this.log('Error in iframe shim', data.error);\n                this.teardown(false);\n                if(this.#errorCb) this.#errorCb(data.error);\n            });\n        }\n\n        setup(){\n            return new Promise(async (resolve) => {\n                const templateData = {\n                    id: this.#id,\n                    url: this.#url,\n                    data: JSON.stringify(this.#metadata)\n                };\n                const html = await TEMPLATES.build('xcom_shim', templateData);\n                document.getElementsByTagName('body')[0].classList.add(BODY_NOSCROLL_CLASS);\n                UI.fullpageUi(html);\n                resolve();\n            });\n        }\n\n        done(){\n            return new Promise((resolve, reject) => {\n                if(this.#errored) return reject();\n                this.#errorCb = reject;\n                this.#doneCb = resolve;\n            });\n        }\n\n        teardown(isDone=true){\n            document.getElementsByTagName('body')[0].classList.remove(BODY_NOSCROLL_CLASS);\n            this.log(`teardown`);\n            globals.RELAY.offAll('xcomShim');\n            if(this.#doneCb && isDone){\n                this.#doneCb();\n                this.#doneCb = null;\n            }\n        }\n    }\n    globals.XcomShim = XcomShim;\n\n})(IRX);\n\n/* globals IRX */\n\n(async (globals) => {\n\n    const state = globals.STATE = globals.STATE || new globals.ContentState();\n    try{\n        // initialize frame Bridge, state, store, etc\n        await state.setup();\n    }catch(e){\n        return console.error(e);\n    }\n\n    let pageButtons;\n    let extract;\n    let configTemplate;\n\n    globals.CONTENT_UTILS.onOrphaned(() => {\n        console.info('Content script orphaned, removing extract functionality!');\n        if(pageButtons){\n            pageButtons.cleanup();\n            pageButtons = null;\n        }\n        if(extract){\n            extract.cleanup();\n            extract = null;\n        }\n    });\n\n    state.onUserChange(async (loggedIn, userInfo) => {\n        console.log('IRX onUserChang, logged In?', loggedIn, userInfo);\n        // Function called when user has changed (log in, log out, proctor updated, etc)\n\n        let advertisersMatch = true;\n        let pageAdvertiserKey;\n        try{\n            pageAdvertiserKey = await globals.Extract.getCurrentPageAdvertiserKey();\n        }catch(e){\n            return console.error(e);\n        }\n\n        if(pageAdvertiserKey !== userInfo.advertiserKey){\n            advertisersMatch = false;\n            console.log(\"Current user advertiser doesn't match page advertiser\", pageAdvertiserKey, userInfo.advertiserKey);\n        }\n\n        if(pageButtons) pageButtons.cleanup();\n        if(extract) extract.cleanup();\n        if(!loggedIn || !advertisersMatch){\n            if(pageButtons) pageButtons = null;\n            if(extract) extract = null;\n            return;\n        }\n\n        try{\n            configTemplate = configTemplate || await globals.configTemplates.get('extract');\n        }catch(e){\n            return console.error(e);\n        }\n\n        console.log('IRX extract initiliazed, user logged in!');\n        const {integrations, reminders} = userInfo;\n\n        if(pageButtons){\n            pageButtons.reset(integrations, reminders);\n        }else{\n            pageButtons = new globals.PageButtons(integrations, reminders, configTemplate);\n        }\n        if(extract){\n            extract.reset();\n        }else{\n            extract = new globals.Extract(state.advertiserKey, configTemplate);\n        }\n    });\n\n})(IRX);\n"]}