{"version":3,"sources":["manifest_popup_bottom_bundle.js"],"names":["globals","LogTools","LoggableClass","constructor","super","purgeForLength","logRows","slice","Math","min","length","removeOld","purgeFromTs","Date","getTime","numPurged","filtered","filter","row","ts","this","log","sortRows","sort","a","b","async","storeItems","storeUtils","getAll","clearKeys","filterToLogSetKeys","concat","delete","combineAndPurge","get","keys","Array","isArray","Object","k","startsWith","Promise","resolve","logSetKeys","prevCombinedRows","forEach","key","logRowsArr","split","v","map","JSON","parse","set","stringify","join","readable","chrome","storage","local","getBytesInUse","floor","log2","rank","count","pow","readbleRows","ts_readable","context","process","data","getLogsDataUri","btoa","getLogs","asText","LOG_TOOLS","IRX","Notifications","EventableClass","eventableClassLevel","isShown","isBadgeCurrentlyVisible","isPinned","extensionUtils","isExtensionIconPinned","featureActionName","markBadgeAsCleared","markBadgeAsShown","featureEvent","test","IframeBindings","boundListeners","componentName","notifications","levels","popup","state","UTILS","isQueryParamPresent","bindAll","lifecycleEvent","trigger","msg","msgRecieved","send","RELAY","componentSend","bind","fn","bindFunctionGlobal","globalBindArgs","componentOn","args","argName","ind","localSend","env","_data","fname","irxUserUuid","dataUri","elem","document","createElement","setAttribute","click","clear","openUrl","url","active","window","close","console","error","reloadSupportedTabs","setBadgeCount","trackFeatureEventFromCount","tabs","query","currentWindow","sendMessage","id","openPopupDebugWindow","markReminderSeen","reminderKey","updatePreferences","preferences","navigator","onLine","getElementById","style","frameId","LOGGER","setFrameId","genericError","addEventListener","restartIfAllowed","xcom","XComWindow","version","ExtensionState","awaitRemoteVersion","e","ExtensionVersionError","STATE","init","clearLoading","href","appendQueryParamToUrl","platformInfo","updateUrl","now","loggedIn","authCookies","currentlySetAuthCookieKeys","includes","getAdvertiserSelectionUrlForEnv","iframeBindings","envInfo","extractAvailable","EXTRACT","extractEnabledOnCurrentPage","stateInfo","info","availableEnvs","availbleEnvironments","windowUrl","location","userInfo","updateStateInfo","setWindowURL","api","popupOnehostUrl"],"mappings":"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","file":"manifest_popup_bottom_bundle.js","sourcesContent":["/* globals IRX, LoggableClass */\n\n((globals) => {\n\n    const COMBINED_STORAGE_KEY = '_LOGS';\n    const STORAGE_KEY_PREF = 'LOGS';\n    const MAX_RETENTION_LOG_ROWS = 10000;\n    const LOG_RETAIN_DURATION_MS = 1000 * 60 * '1440';\n\n    class LogTools extends LoggableClass {\n        constructor() {\n            super(false, false);\n        }\n\n        #purgeForLength(logRows){\n            return logRows.slice(0, Math.min(MAX_RETENTION_LOG_ROWS, logRows.length));\n        }\n\n        #removeOld(logRows){\n            let purgeFromTs = (new Date().getTime() - LOG_RETAIN_DURATION_MS);\n            let numPurged = 0;\n            const filtered = logRows.filter(row => {\n                if (row.ts < purgeFromTs) {\n                    numPurged++;\n                    return false;\n                }\n                return true;\n            });\n            this.log(`Purged ${numPurged} old log rows. (of ${logRows.length})`);\n            return filtered;\n        }\n\n        #sortRows(logRows){\n            // sort newest to oldest (so new are preserved if we truncate)\n            logRows.sort((a,b) => {\n                return b.ts - a.ts;\n            });\n        }\n\n        async clear(){\n            const storeItems = await globals.storeUtils.getAll();\n            const logSetKeys = this.#filterToLogSetKeys(storeItems);\n            const clearKeys = logSetKeys.concat([COMBINED_STORAGE_KEY]);\n            this.log('Clearing all log keys', clearKeys);\n            return globals.storeUtils.delete(clearKeys);\n        }\n\n        async getAll(){\n            await this.combineAndPurge();\n            return globals.storeUtils.get(COMBINED_STORAGE_KEY);\n        }\n\n        #filterToLogSetKeys(keys){\n            if(!Array.isArray(keys)) keys = Object.keys(keys);\n            return keys.filter(k => k.startsWith(`${STORAGE_KEY_PREF}_` || k.startsWith('_LOGS_')));\n        }\n\n        // returns promise that resolves to an array of all log items\n        combineAndPurge(){\n            return new Promise(async (resolve) => {\n                this.log('Running combine & purge.');\n                // get everything from storage and coalesce all the log stuff\n                const storeItems = await globals.storeUtils.getAll();\n                const logSetKeys = this.#filterToLogSetKeys(storeItems);\n\n                this.log('Storage keys for logs', logSetKeys);\n                if(logSetKeys.length) await globals.storeUtils.delete(logSetKeys);\n\n                let prevCombinedRows = (storeItems[COMBINED_STORAGE_KEY] || '');\n                let logRows = prevCombinedRows;\n                logSetKeys.forEach(key => { logRows += '\\n' + storeItems[key]; });\n\n                // TODO -- do we need to do this now???\n                let logRowsArr = logRows.split('\\n').filter(v => v !== '').map(row => JSON.parse(row));\n\n                logRowsArr = this.#removeOld(logRowsArr);\n                logRowsArr = this.#purgeForLength(logRowsArr);\n                this.#sortRows(logRowsArr);\n\n                if (!logRowsArr.length) {\n                    return this.log('Combine not writing anything, no rows to write.');\n                }\n\n                await globals.storeUtils.set(COMBINED_STORAGE_KEY, logRowsArr.map(row => JSON.stringify(row)).join('\\n'));\n                this.log(`Adding ${logSetKeys.length} sets, ${logRowsArr.length} total rows (${prevCombinedRows.split('\\n').length} previously).`);\n                resolve(logRowsArr);\n            });\n        }\n\n        async getSize(readable = true){\n            const storeItems = await globals.storeUtils.getAll();\n            const logSetKeys = this.#filterToLogSetKeys(storeItems);\n            let combined = await chrome.storage.local.getBytesInUse(COMBINED_STORAGE_KEY);\n            let toWrite = await chrome.storage.local.getBytesInUse(logSetKeys);\n            const b = combined + toWrite;\n\n            const k = b > 0 ? Math.floor((Math.log2(b)/10)) : 0;\n            const rank = (k > 0 ? 'KMGT'[k - 1] : '') + 'b';\n            const count = Math.floor(b / Math.pow(1024, k));\n            return readable ? `${count} ${rank}` : b;\n        }\n\n        // Format row or logs as readable text\n        #readbleRows(logRows) {\n            return logRows.map(row => {\n                return `${row.ts_readable} : ${row.context} [${row.process}] >>> ${JSON.stringify(row.data)}`;\n            }).join('\\n');\n        }\n\n        getLogsDataUri(){\n            return new Promise(async (resolve) => {\n                let logRows = await this.combineAndPurge();\n                //format the logs for readability\n                let textB64 = btoa(this.#readbleRows(logRows));\n                resolve('data:text/plain;base64,' + textB64);\n            });\n        }\n\n        getLogs(asText = false){\n            return new Promise(async (resolve) => {\n                let logRows = await this.combineAndPurge();\n                if (asText) logRows = this.#readbleRows(logRows);\n                resolve(logRows);\n            });\n        }\n    }\n\n    globals.LOG_TOOLS = new LogTools();\n})(IRX);\n\n/* globals IRX */\n\n((globals) => {\n\n    const WAS_BADGE_SHOWN_STORE_KEY = 'taskbarBadgeShown';\n    const FEATURE_NAME = 'notifications';\n\n    class Notifications extends globals.EventableClass {\n        constructor(eventableClassLevel) {\n            super(false, eventableClassLevel);\n        }\n\n        async trackFeatureEventFromCount(count){\n            let isShown = await this.isBadgeCurrentlyVisible();\n            // get isPinned\n            const isPinned = await globals.extensionUtils.isExtensionIconPinned();\n            let featureActionName;\n\n            if(isShown && count === 0){\n                // notifications were cleared\n                await this.#markBadgeAsCleared();\n                featureActionName = `taskbar_badge_cleared_${isPinned ? 'pinned' : 'unpinned'}`;\n\n            }else if(!isShown && count > 0){\n                // notifications are being shown\n                await this.#markBadgeAsShown();\n                featureActionName = `taskbar_badge_impression_${isPinned ? 'pinned' : 'unpinned'}`;\n            }\n\n            if(featureActionName){\n                this.log('Logging feature event for notification:', featureActionName);\n                await this.featureEvent(FEATURE_NAME, featureActionName);\n            }\n        }\n\n        // returns a promise\n        isBadgeCurrentlyVisible(){\n            return globals.storeUtils.get(WAS_BADGE_SHOWN_STORE_KEY) || false;\n        }\n\n        // returns a promise\n        #markBadgeAsShown(){\n            globals.storeUtils.set(WAS_BADGE_SHOWN_STORE_KEY, true);\n        }\n\n        // returns a promise\n        #markBadgeAsCleared(){\n            return globals.storeUtils.set(WAS_BADGE_SHOWN_STORE_KEY, false);\n        }\n\n        test(){\n            return 'foo';\n        }\n    }\n\n    globals.Notifications = Notifications;\n\n})(IRX);\n\n/* globals IRX, EventableClass */\n\n((globals) => {\n\n\n    class IframeBindings extends EventableClass {\n        #boundListeners = {};\n        #componentName;\n        #notifications = new globals.Notifications(EventableClass.levels.popup);\n\n        constructor(state, componentName){\n            const debugOverride = globals.UTILS.isQueryParamPresent('messageDebug');\n            super(debugOverride || false, EventableClass.levels.popup);\n            this.#componentName = componentName;\n            this.#bindAll(state);\n\n            this.lifecycleEvent('popup_window_opened');\n        }\n\n        trigger(msg, data=null){\n            if(msg in this.#boundListeners){\n                this.#boundListeners[msg](data);\n            }\n        }\n\n        #msgRecieved(msg, data){\n            this.log('::MESSAGE FROM IFRAME >> ', msg, data);\n            this.#boundListeners[msg](data);\n        }\n\n        #send(msg, data=null){\n            globals.RELAY.componentSend(msg, data, this.#componentName);\n        }\n\n        #bind(msg, fn, bindFunctionGlobal = true, globalBindArgs = []){\n            this.#boundListeners[msg] = fn;\n            globals.RELAY.componentOn( msg, this.#componentName,(data) => {\n                this.#msgRecieved(msg, data);\n            });\n\n            if(bindFunctionGlobal){\n                this.log(`Binding global function ${msg}(${globalBindArgs})`);\n                globals[msg] = (...args) => {\n                    let data = {};\n                    globalBindArgs.forEach((argName, ind) => {\n                        data[argName] = args[ind];\n                    });\n                    args.length > 0 ? this.#boundListeners[msg](data) : this.#boundListeners[msg]();\n                };\n            }\n        }\n\n        #bindAll(state) {\n            this.log('binding all iframe listeners');\n\n            this.#bind('setEnv', (data) => {\n                globals.RELAY.localSend('changeEnv.state', {env: data.env});\n            }, true, ['env']);\n\n            this.#bind('downloadLogs', async (_data) => {\n                const irxUserUuid = state.irxUserUuid;\n                const fname = 'IRX_LOGS_' + (irxUserUuid || 'no_user') + '_' + new Date().getTime() + '.txt';\n                const dataUri = await globals.LOG_TOOLS.getLogsDataUri();\n                let elem = document.createElement('a');\n                elem.setAttribute('download', fname);\n                elem.setAttribute('href', dataUri);\n                elem.click();\n                this.#send('downloadLogsResponse');\n            });\n\n            this.#bind('purgeLogs', async (_data) => {\n                await globals.LOG_TOOLS.clear();\n                this.#send('purgeLogsResponse');\n            });\n\n            this.#bind('resetNotifications', async () => {\n                await globals.storeUtils.delete('reminders');\n                this.#send('resetNotificationsResponse');\n            });\n\n            this.#bind('openUrl', async (data) => {\n                await globals.extensionUtils.openUrl(data.url, data.active);\n                // TODO -- make some decision on window close?\n                if(data.active !== false) window.close();\n            }, false, ['url']);\n\n            this.#bind('advertiserChanged', (_data) => {\n                console.error('DO RELOAD OF TABS');\n                globals.extensionUtils.reloadSupportedTabs();\n            });\n\n            this.#bind('setIconBadgeCount', async (data) => {\n                globals.extensionUtils.setBadgeCount(data.count);\n                await this.#notifications.trackFeatureEventFromCount(data.count);\n            }, ['count']);\n\n            this.#bind('desktopNotification', async (_data) => {\n                // TODO\n                // globals.extensionUtils.desktopNotification();\n            });\n\n            this.#bind('extract', async (_data) => {\n                let tabs = await chrome.tabs.query({active: true, currentWindow: true});\n                if(!tabs || !tabs.length) return console.error('No available tabs');\n\n                await chrome.tabs.sendMessage( tabs[0].id, 'popup.extract');\n                window.close();\n            });\n\n            this.#bind('openPopupAsWindow', async () => {\n                globals.extensionUtils.openPopupDebugWindow();\n                window.close();\n            }, true);\n\n            this.#bind('markReminderSeen', async (data) => {\n                await state.markReminderSeen(data.reminderKey);\n                this.#send('markReminderSeenResponse', {reminderKey: data.reminderKey});\n            }, true, ['reminderKey']);\n\n            this.#bind('updatePreferences', async (data) => {\n                await state.updatePreferences(data.preferences);\n                await globals.extensionUtils.reloadSupportedTabs();\n                this.#send('updatePreferencesResponse');\n            }, true, ['preferences']);\n        }\n    }\n    \n    globals.IframeBindings = IframeBindings;\n})(IRX);\n\n/* globals IRX */\n\n(async (globals) => {\n\n    // Handle case where browser is offline\n    if(!navigator.onLine){\n        console.error('Computer is currently offline!');\n        return document.getElementById('offline').style = ''; // clear display none\n    }\n\n    // Setup frameID & logging\n    const frameId = new Date().getTime();\n    globals.LOGGER.setFrameId(frameId);\n\n    // Function for generic error (if metadat fetch error, issue with XCOM, etc)\n    const genericError = () => {\n        document.getElementById('generic_error').style = ''; // clear display none\n    };\n\n    // Bind listerner for 'Reload' button click\n    document.getElementById('reload_extension').addEventListener('click', async () => {\n        await globals.extensionUtils.restartIfAllowed(0);\n    });\n\n    // Wire up XCOM component\n    const COMPONENT_NAME = 'irxPopup';\n    const xcom = new globals.XComWindow({}, COMPONENT_NAME, genericError);\n\n    // Initialize the state and await remote version (initial extension setup)\n    let version;\n    try{\n        version = await globals.ExtensionState.awaitRemoteVersion();\n    }catch(e){\n        if(e instanceof globals.ExtensionVersionError){\n            return genericError();\n        }\n    }\n\n    // Initialize the state and the load the store / user login info\n    const state = globals.STATE = new globals.ExtensionState(true, version);\n    try{\n        await state.init();\n    }catch(e){\n        xcom.clearLoading();\n\n        // If the extension is out of data and needs a forced update, show that UI\n        if(e instanceof globals.ExtensionVersionError){\n            document.getElementById('needs_update').style = ''; // clear display none\n            const link = document.getElementById('update_url');\n            link.href = globals.UTILS.appendQueryParamToUrl(globals.ExtensionState.platformInfo.updateUrl, 'nonce', Date.now());\n            return;\n        }\n    }\n\n    if(!state.loggedIn && !(await globals.authCookies.currentlySetAuthCookieKeys()).includes('PCA')){\n        xcom.clearLoading();\n        document.getElementById('no_advertiser_error').style = ''; // clear display none\n        const advBtn = document.getElementById('select_advertiser_url');\n        advBtn.href = globals.ExtensionState.getAdvertiserSelectionUrlForEnv(state.env);\n        return;\n    }\n\n    // Setup the bindings + comm for oneHost iframe, and build the envInfo payload sent to it\n    globals.iframeBindings = new globals.IframeBindings(state, COMPONENT_NAME);\n\n    let envInfo = {\n        extractAvailable: await globals.EXTRACT.extractEnabledOnCurrentPage(),\n        stateInfo: state.info,\n        availableEnvs: state.availbleEnvironments,\n        version: state.version,\n        windowUrl: window.location.href,\n        userInfo: state.userInfo\n    };\n    console.info('Popup envInfo', JSON.parse(JSON.stringify(envInfo)));\n\n    xcom.updateStateInfo(envInfo);\n    // Now load the actual oneHost iframe\n    xcom.setWindowURL(state.info.api.popupOnehostUrl);\n})(IRX);\n\n"]}