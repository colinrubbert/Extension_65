{"version":3,"sources":["manifest_page_primary_bundle.js"],"names":["globalThis","IRX","this","irxGlobals","globals","relay","namespace","relayLevel","debug","targetDomain","_debug","LEVELS","Object","freeze","service_worker","content","page","iframe","iframe_shim","test","LEVEL_ORDER","level","_receivedMessages","_receivedMsgCleanTmo","_relayNamespace","_lastSender","_lastMsg","_listeners","_onComponentInitializedFns","_componentEnvData","_componentLocalOverride","COMPONENT_STATE","ready","initEnv","initialized","_components","_bind","msgTypes","cb","limitFromLevels","isOnce","componentFilter","Array","isArray","forEach","msgType","mtypeInfo","_getMtypeInfo","type","push","fn","ns","_unbind","componentId","_unbindNamspaceListenersForMessageType","_buildMsgTypeFromParts","component","matches","split","match","filter","l","length","_getMsg","dest","sourceLevel","up","data","msgId","_validateData","_guid","_buildMsgId","msgObj","msgFrom","msgDestination","msgUp","relayNamespace","msgData","msgTabId","destObj","_parseDestination","tabId","_sendMsg","destinations","mtypeParts","_isValidDestination","_log","destLevel","_sendDown","destination","msg","JSON","stringify","_relay","_sendUp","thisLevel","parent","postMessage","includes","i","frames","iframes","document","getElementsByTagName","startsWith","getAttribute","_componentIdDataAttr","target","chrome","runtime","id","src","contentWindow","_relayFromToLevel","_incomingMessage","sender","msgReceptionId","msg_id","cWindow","from","find","ifr","dataAttr","setAttribute","new_msgType","_buildComponentStateMsgType","compName","_componentNameFromId","item","name_filter","localeCompare","listeners","listener","limitFrom","listenerCompFilter","filterCheck","replace","call","splice","_callBoundListeners","parts","parseInt","tab_id","ChromeExtensionMessageRelayError","newData","parse","e","console","log","_localSendMsg","_componentSend","componentName","forceLocal","_deleteInterval","Math","random","toString","substring","message","name","stack","Error","setInterval","prototype","create","constructor","addEventListener","event","translated","key","msg_namespace","letter","toUpperCase","translateFromLegacyMessageFormat","source","RETURNS","levels","curLevel","on","onOnce","off","componentOff","offAll","send","levelViaTabId","levelViaComponentId","getLastMsgSenderInfo","getLastMsgType","getLastMsg","mockSend","localSend","componentSend","componentLocalSend","componentOn","targetComponent","componentRespond","last","clearTMO","clearInterval","registerComponentInitializedCb","nameFilter","setComponentEnvData","envData","setOverrideLocalComponentInit","getComponentEnvData","Component","enabled","_componentName","_componentId","_ready","_initialized","_pendingInitCalls","_limitLevels","_initMsg","markReady","initEnvCallback","_","initReturn","shift","Promise","resolve","markInitialized","args","items","arguments","unshift","warn","newComponent","component_name","module","exports","chromeExtensionMessageRelay","chrome_extension_message_relay","window","LoggableClass","_logging","_debugColor","recordLogs","classLogName","getEnv","async","storeUtils","get","debugColor","klass","possibleColors","floor","debugConsole","LOGGER","allArgs","concat","logNoStore","RELAY","IS_DEV","_push","process","context","logData","logs","elem","error"],"mappings":"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","file":"manifest_page_primary_bundle.js","sourcesContent":["if(typeof globalThis !== 'undefined'){\n    globalThis.IRX = globalThis;\n}\nif(!('IRX' in this)) this.IRX = {};\n// TODO: remove irxGlobals alias\nif (!('irxGlobals' in this)) this.irxGlobals = this.IRX;\n\n\n/* Version 3.0.11 chrome-extension-message-relay (https://github.com/ecaroth/chrome-extension-message-relay), Authored by Evan Carothers */\n\n// IMPORTANT NOTE!\n// DO NOT use this version of the script in production, this is the dev/build version that exposes internal\n// functions for testing. Use the modified, minified version in /dist/message_relay.prod.js\n\n\n\n/* MODULE_EXPORTS */ ((globals) => {\n\n    const relay = function( namespace, relayLevel, debug, targetDomain ){\n        if(!targetDomain) targetDomain = \"*\";\n\n        const _debug = debug || false,\n\n            LEVELS = Object.freeze({             // available levels msg relay can be used at\n                service_worker:  'service_worker',  // relay running in chrome extension\n                content:    'content',              // relay running in content script\n                page:       'page',                 // relay running on web page\n                iframe:     'iframe',               // relay running in iframe\n                iframe_shim:'iframe_shim',          // relay running in an iframe shim (see readme)\n                test:       'test'                  // relay for unit testing\n            }),\n            LEVEL_ORDER = Object.freeze({           // ordering of levels (indicitive of how messages can bubble up/down)\n                service_worker: 4,\n                content:        3,\n                page:           2,\n                iframe_shim:    1,\n                iframe:         0,\n                test:           -1\n            }),\n            level = relayLevel;                          // relay level (one of 'content','page','iframe','extension') - the level that THIS relay is listening at\n\n        let _receivedMessages = {},                      // digest of all received messages by msgId, which is cleaned out every 2 mins to keep memory usage down\n            _receivedMsgCleanTmo = null,                 // tmo for setTimeout call used to clean _receivedMessages digest every 2 minutes\n            _receivedMsgCleanIntervalSecs = 2*60,        // 2 mins between digest cleaning intervals\n            _relayNamespace = namespace,                 // the namespace for your msg relay - used to capture and identify relay msgs from other postMsg traffic \"docalytics.message\";   //\n            _lastSender = null,                          // info about the last message sender\n            _lastMsg = null,                             // the last received message (type, component, namespace))\n            _listeners = {},                             // bound listeners for the relay (at this level)\n            // _contentScriptsReady = {},                // used by extension level only, to track what content scripts in tabIds are ready\n            _contentScriptConnectPort = null,            // used by content script level only, to hold variable for chrome.rumtime port to extension\n            _onComponentInitializedFns = [],             // FNs to call when a component is initialized. Format is (componentName, iframeRef, windowRef)\n            _componentEnvData = {},                      // hash of env data to pass to iframed components when they initialize (only used in content)\n            _componentLocalOverride = false;             // For testing/debug, short-circuit actual component inti lifecycle\n\n        const COMPONENT_STATE_NS = '_CSTATE';\n        const COMPONENT_STATE = Object.freeze({\n            ready: 'ready',\n            initEnv: 'initEnv',\n            initialized: 'initalized'\n        });\n        const _components = {};\n        const MSG_ID_ASSIGNMENT_DELIM = \"@@@\";\n        const COMPONENT_NAME_ALL_PREFIX = \"***\";\n\n        // =============== START OF TEST-ONLY VARIABLE DEFS ====================\n\n\n\n        // =============== END OF TEST-ONLY VARIABLE DEFS ====================\n\n        // This function allows you to bind any msg type as a listener, and will ping the callback when the message comes to this level (exposed as <instance>.on)\n        // you can also namespace msg types with msgType.namespace, or specify no namespace\n        // limitFrom_level allows you to limit the incoming messages that listener will fire on for security purposes\n        function _bind( msgTypes, cb, limitFromLevels= null, isOnce=false, componentFilter = null){\n            if( typeof msgTypes === 'string' ) msgTypes = [msgTypes];\n            if(limitFromLevels && !Array.isArray(limitFromLevels)) limitFromLevels = [limitFromLevels];\n\n            msgTypes.forEach((msgType) =>{\n                let mtypeInfo = _getMtypeInfo(msgType);\n                if(!(mtypeInfo.type in _listeners)) _listeners[mtypeInfo.type] = [];\n                _listeners[mtypeInfo.type].push({\n                    fn: cb,\n                    ns: mtypeInfo.namespace,\n                    limitFromLevels,\n                    componentFilter,\n                    isOnce\n                });\n            });\n        }\n\n        //this function allows you to unbind any msg type as a listener (with a sepcified namespace or ALL events of this type(s) if no namespace is supplied)\n        function _unbind(msgTypes, componentId=null){\n            // TODO handle componentId ? (might not be needed)\n            if(componentId){}\n\n            if(!msgTypes) return;\n            if( typeof msgTypes === 'string' ) msgTypes = [msgTypes];\n\n            msgTypes.forEach((msgType) => {\n                let mtypeInfo = _getMtypeInfo(msgType);\n\n                if(mtypeInfo.type in _listeners){\n                    if(!mtypeInfo.namespace){\n                        //unbind ALL listeners on this message type\n                        delete _listeners[mtypeInfo.type];\n                    }else{\n                        //find only messages bound on this namespace/type\n                        _unbindNamspaceListenersForMessageType( mtypeInfo.type, mtypeInfo.namespace );\n                    }\n                }\n            });\n        }\n\n        function _buildComponentStateMsgType(type, componentId){\n            return _buildMsgTypeFromParts(type, COMPONENT_STATE_NS, componentId);\n        }\n\n        function _buildMsgTypeFromParts(type, namespace=null, componentId=null){\n            let msgType = type;\n            if(namespace) msgType += '.' + namespace;\n            if(componentId){\n                msgType += `[${componentId}]`;\n            }\n            return msgType;\n        }\n\n        //this function parses message type into component parts (type && namespace)\n        function _getMtypeInfo(msgType){\n            // possible formats:\n            // 'foo'            - standard message\n            // 'foo.bar'        - namespaced message\n            // 'foo.bar[@baz]   - namespace message with component (also non namespaced w/ component)\n\n            // NOTE this also splits message ID off\n            msgType = msgType.split(MSG_ID_ASSIGNMENT_DELIM)[0];\n\n            let type = null, namespace = null, component = null;\n\n            const re = /^([\\w:_-]+)\\.?([\\w:_-]+)?(\\[(.+)])?$/;\n            const matches = msgType.match(re);\n            if(matches[2]){\n                namespace = matches[2];\n                type = matches[1];\n            }else{\n                type = matches[1];\n            }\n            if(matches[4]) component = matches[4];\n\n            return {type, namespace, component};\n        }\n\n        //utility function to unbind all namespaced listeners for supplied message type\n        function _unbindNamspaceListenersForMessageType( msgType, namespace ){\n            if(!(msgType in _listeners)) return;\n            _listeners[msgType] = _listeners[msgType].filter(l => l.ns !== namespace);\n            if(!_listeners[msgType].length) delete _listeners[msgType];\n        }\n\n        //this function unbinds ALL listeners, or all listeners for a specific namespace\n        function _unbindAll( namespace ){\n            if( !namespace){\n                _listeners = {};\n            }else{\n                for(let msgType in _listeners){\n                    _unbindNamspaceListenersForMessageType(msgType, namespace);\n                }\n            }\n        }\n\n        function _buildMsgId(dest, msgType){\n            return `${dest}:${msgType}${MSG_ID_ASSIGNMENT_DELIM}${_guid()}`;\n        }\n\n        //get the base msg object used for relaying\n        function _getMsg( type, dest, sourceLevel, up, data ){\n            // try stringify and parse message data to make sure nothing invalid is included\n            data = _validateData(data);\n\n            // type = string, message type (specified when calling send_up or send_down)\n            // dest = destination level (one of LEVELS) - NOTE: can specific a specific tab.id to use only by specifying a @tab.id\n            // sourceLevel = origin source level where message was sent from\n            // up = boolean, is this message going upwards (else going down)\n            // data = javascript variable to pass with message\n            let msgId = ('msgId' in data) ? data.msgId : _buildMsgId(dest, type);\n            data.msgId = msgId;\n            let msgObj = {\n                msgType:            type,\n                msgFrom:            level,\n                sourceLevel:        sourceLevel,\n                msgDestination:     dest,\n                msgUp:              up,\n                relayNamespace:     _relayNamespace,\n                msgData:            data,\n                msgId:              msgId,\n                msgTabId:           null\n            };\n            const destObj = _parseDestination(dest);\n            if( destObj.tabId ){\n                msgObj.msgDestination = destObj.level;\n                msgObj.msgTabId = destObj.tabId;\n            }\n            return msgObj;\n        }\n\n        // send a message reponse to the last component message received\n        function _componentRespond(msgType, data){\n            const last = _lastMsg;\n            if(last.component) {\n                _sendMsg(msgType, LEVELS.iframe, data, last.component);\n            }\n        }\n\n        //send a message to the specified level(s) - NOTE destinations can be a string or array of destination strings\n        function _sendMsg( msgType, destinations, data, componentId=null ){\n            data = _validateData(data);\n\n            if( typeof destinations === 'string' ) destinations = [destinations];\n\n            if(componentId) {\n                const mtypeParts = _getMtypeInfo(msgType);\n                msgType = _buildMsgTypeFromParts(mtypeParts.type, mtypeParts.namespace, componentId);\n            }\n\n            destinations.forEach((dest) => {\n                if( !_isValidDestination(dest) ){\n                    return _log(`NOTICE - invalid level specified as destination (${dest})`);\n                }\n\n                const destLevel = _parseDestination(dest).level;\n\n                if (LEVEL_ORDER[destLevel] < LEVEL_ORDER[level]) {\n                    _sendDown(msgType, dest, data);\n                } else {\n                    _sendUp(msgType, dest, data);\n                }\n\n            });\n        }\n\n        //send a message DOWN the listening stack (exposed as <instance>.send_down)\n        function _sendDown( msgType, destination, data= {}){\n            const msg = _getMsg( msgType, destination, level, false, data );\n            _log( `Send msg DOWN from ${level} to ${destination} : ${msgType} - ${JSON.stringify(data)}`);\n            _relay(msg);\n        }\n\n        //send a message UP the listening stack (exposed as <instance>.send_up)\n        function _sendUp( msgType, destination, data ){\n            const msg = _getMsg( msgType, destination, level, true, data );\n            _log( `Send msg UP from ${level} to ${destination} : ${msgType} - ${JSON.stringify(data)}`);\n            _relay(msg);\n        }\n\n        //fn to relay a message from thisLevel either up/down (using appropriate method baesd on data.msgDestination)\n        function _relayFromToLevel(thisLevel, msg){\n\n            /*\n            TODO -- fix for service worker\n            if( thisLevel === LEVELS.service_worker){\n                // TODO\n            }else\n            */\n            if( (thisLevel === LEVELS.content && msg.msgDestination === LEVELS.service_worker) || thisLevel === LEVELS.service_worker ){\n                //going UP form content script to extension. use connected runtime port\n\n\n\n\n                    // verify that message is coming from script within your extension\n                    // NOTE this will prevent external connectible messages from outside your extension,\n                    // but we want that for security reasons\n\n                    if(_contentScriptConnectPort) {\n                        _contentScriptConnectPort.postMessage(msg);\n                    }\n\n            }else{\n                //no interaction with extension background, broadcast UP w/ postmessage so content/page can receive\n                if( thisLevel === LEVELS.iframe || (msg.msgDestination !== LEVELS.iframe && thisLevel === LEVELS.iframe_shim)) {\n\n\n\n                        globals.parent.postMessage(msg, targetDomain);\n\n                }else if( (thisLevel === LEVELS.page || thisLevel === LEVELS.content) && [LEVELS.iframe, LEVELS.iframe_shim].includes(msg.msgDestination)){\n                    //going DOWN from content/page to iframe, so postMessage to iframe(s) directly\n\n\n\n\n\n                        const iframes = document.getElementsByTagName('iframe');\n                        const {component} = _getMtypeInfo(msg.msgType);\n                        for(let i=0; i<iframes.length; i++){\n\n                            // TODO -- handle specific `component` logic here\n                            if(component && !component.startsWith(COMPONENT_NAME_ALL_PREFIX)){\n                                // if this message is targetted at a specific component only send to that iframe\n                                // NOTE this might be overkill as it'll get filtered out in the iframe relays anyway,\n                                // it just keeps down chatter\n                                if(iframes[i].getAttribute(_componentIdDataAttr(component)) !== COMPONENT_STATE.ready){\n                                    continue;\n                                }\n                            }\n\n                            let target = '*';\n                            if(level === LEVELS.content) {\n                                // If sending from content, only send the message to iframes in our extension\n                                target = \"chrome-extension://\" + chrome.runtime.id;\n                                if (!iframes[i].src.startsWith(target)) continue;\n                            }\n                            // TODO -- handle whitelisting domains if NOT shimming???\n                            iframes[i].contentWindow.postMessage(msg, target);\n                        }\n\n                }else{\n                    // communication between content and page directly (UP or DOWN) or from content to iframe_shim or iframe_shim to iframe\n\n\n\n\n\n                        // determine target and set targetOrigin appropriately\n                        if(msg.msgDestination === LEVELS.iframe && thisLevel === LEVELS.iframe_shim){\n                            // sending DOWN to sub-frames from iframe shim\n                            // NOTE this makes the assumption that we want to post to all sub-frames within the shim\n                            // if we want to restrict which frames it is passed to, this will need to change\n                            for (let i=0; i < globals.frames.length; i++) {\n                                globals.frames[i].postMessage(msg, \"*\");\n                            }\n                        }else {\n                            globals.postMessage(msg, \"*\");\n                        }\n\n                }\n            }\n        }\n\n        //This function is used by both send_up and send_down to relay a message the proper direction\n        function _relay( msgObj){\n            _relayFromToLevel( level, msgObj );\n        }\n\n        //This function is called for every incoming message to this level and determines if the messsage is intended for this level\n        //(and calls needed listeners) or continues relaying it upwards/downwards\n        function _incomingMessage( msg, sender ){\n            //searialize/unserialize msg object so we don't end up with closure memory leaks, then assign\n            const {msgData, msgFrom, sourceLevel, msgUp, msgDestination, msgType, msgId} = msg;\n\n            //set last sender & last message type\n            if(sender) _lastSender = sender;\n            _lastMsg = _getMtypeInfo(msgType);\n\n            const msgReceptionId = `${msgId}:${msgDestination}`;\n\n            if(msgFrom === level || (msgReceptionId in _receivedMessages)){\n                // Message already received - need this because page scripts and content scripts listen at same\n                // postMessage level and we don't want to relay it twice if it's a pass-through\n                return false;\n            }\n\n            if( msgDestination === level ){\n                // Message intended for this level, call any bound listeners\n                _log( `Msg (${msgType}) received from ${msgFrom} to ${msgDestination} - ${JSON.stringify(msgData)}` );\n                _receivedMessages[msgReceptionId] = 0;\n\n\n\n\n                    _callBoundListeners( msgType, msgData, sourceLevel );\n\n            }else{\n                // Message still bubbling up/down, just relay if needed\n                msg.msgFrom = level;\n\n\n\n\n                    if(msgUp && LEVEL_ORDER[level] > LEVEL_ORDER[msgFrom]){\n                        _relay( msg );\n                        _log( `Msg (${msgType}) relaying UP from ${msgFrom} to ${msgDestination} - ${JSON.stringify(msgData)}` );\n                    }else if(!msgUp && LEVEL_ORDER[level] < LEVEL_ORDER[msgFrom]){\n                        _relay( msg );\n                        _log( `Msg (${msgType}) relaying DOWN ${msgFrom} to ${msgDestination} - ${JSON.stringify(msgData)}` );\n                    }\n\n            }\n        }\n\n        // convert a component ID like 'Name{12313123123}' to a data attribute friendly value\n        function _componentIdDataAttr(component){\n            return \"relay-component-\" + component.replace(/[\\W]/g,'-').replace(/-+$/,'');\n        }\n\n        // parse a component's name from it's ID\n        function _componentNameFromId(id){\n            // format is 'componentName{GUID-ID-..}'\n            const matches = id.match(/^(.+){[a-z0-9-]+}$/);\n            return matches ? matches[1] : null;\n        }\n\n        //call all bound listeners for this message type at this level\n        function _callBoundListeners( msgType, msgData, sourceLevel ){\n            // handle special component-case messages\n\n            // strip msgId from data\n            delete msgData.msgId;\n            delete msgData.msg_id; // for LEGACY messages from v2\n\n            const {component, namespace, type} = _getMtypeInfo(msgType);\n\n            if(component){\n                if([LEVELS.content, LEVELS.page, LEVELS.iframe_shim].includes(level)){\n                    // Handle specific reception cases in parent (CONTENT/PAGE)\n\n                    const cWindow = _lastSender;\n                    const iframe = Array.from(document.getElementsByTagName(\"iframe\")).find(ifr => {\n                        return ifr.contentWindow === cWindow;\n                    });\n\n                    if (namespace === COMPONENT_STATE_NS) {\n                        // receiving a component status message from iframe/shimmed iframe componenet to content\n                        if (type === COMPONENT_STATE.ready) {\n                            _log(`Component ${component} is ready`);\n                            // when an iframe component says it's ready, send down the initEnv data and mark the component as\n                            // existing in that specific frame\n\n                            const dataAttr = _componentIdDataAttr(component);\n                            iframe.setAttribute(dataAttr, COMPONENT_STATE.ready);\n\n                            let new_msgType = _buildComponentStateMsgType(COMPONENT_STATE.initEnv, component);\n                            return _sendDown(new_msgType, LEVELS.iframe, _componentEnvData);\n                        }\n                        if (type === COMPONENT_STATE.initialized) {\n                            // when iframe is component is fully initialized, set the component ID on the iframe and alert\n                            // any fire an explicity call to component ready listeners\n                            // TODO\n                            // _lastSender is event.source -- it *SHOULD* be a window object\n                            // use that to verify that the window has a component ID marked as present in this iframe\n                            // via the data-relay-component-ids attribute!\n                            const compName = _componentNameFromId(component);\n                            _onComponentInitializedFns.forEach(item => {\n                                if(item.name_filter && compName.localeCompare(item.name_filter) !== 0) return;\n                                item.fn(compName, iframe, _lastSender);\n                            });\n                        }\n                        // TODO -- anything else?\n                    }\n                }\n            }\n\n            if(!(type in _listeners)) return;\n\n            const listeners = _listeners[type];\n            for(let i=listeners.length-1; i >=0; i--){\n                const listener = listeners[i];\n                const limitFrom = listener.limitFromLevels;\n                if(!limitFrom || limitFrom.includes(sourceLevel)){\n\n                    if(component && [LEVELS.page, LEVELS.content, LEVELS.iframe_shim].includes(level)) {\n                        const listenerCompFilter = listener.componentFilter;\n\n                        if (listenerCompFilter !== COMPONENT_NAME_ALL_PREFIX) {\n                            const filterCheck = listenerCompFilter || \"\";\n                            if(!filterCheck.startsWith(COMPONENT_NAME_ALL_PREFIX) && component !== listenerCompFilter){\n                                // message targetted at a specific component ID, and this aint it\n                                return;\n                            }\n                            if(filterCheck.startsWith(COMPONENT_NAME_ALL_PREFIX)){\n                                // at this point we know it's a name-targetted component like '***COMPONENT_NAME'\n                                const compName = _componentNameFromId(component);\n                                if (compName !== listenerCompFilter.replace(COMPONENT_NAME_ALL_PREFIX, '')) {\n                                    // componenet name for this listener does NOT match the target\n                                    return;\n                                }\n                            }\n\n                        }\n                    }\n\n                    listener.fn.call( listener, msgData );\n                    if(listener.isOnce) listeners.splice(i, 1);\n                }\n            }\n        }\n\n        //check if a level is an actual context level (or level w/ tab.id)\n        function _isValidDestination(dest){\n            if(!dest) return false;\n            return (_parseDestination(dest).level in LEVELS);\n        }\n\n        //function to parse a destination address and return level (and optionally set tab.id)\n        function _parseDestination(dest){\n            let parts = dest.split(\"@\");\n            let tabId = parts.length > 0 ? parseInt(parts[1],10) : null;\n            return {\n                level:  parts[0],\n                tab_id: tabId, // legacy support\n                tabId\n            };\n        }\n\n        // validate that data is actual encodable JSON and make a copy\n        function _validateData(data){\n            if(data === null || data === undefined) data = {};\n            if(typeof data !== 'object'){\n                throw new ChromeExtensionMessageRelayError(\"Data payload for message must be an object\");\n            }\n            let newData;\n            try{\n                newData = JSON.parse(JSON.stringify(data));\n            }catch(e){\n                throw new ChromeExtensionMessageRelayError(\"Data payload for message included non-JSON-serizable data\");\n            }\n            return newData;\n        }\n\n        //function to direct a message through channels via specific tab.id\n        function _levelViaTabId( level, tabId ){\n            return `${level}@${tabId}`;\n        }\n\n        // Function to direct a message through channels specific to an iframe w/ a containing component\n        function _levelViaComponentId( componentId ) {\n            return `${level}@${componentId}`;\n        }\n\n        //log function (that fires only if debug is enabled)\n        function _log( msg ){\n            if(!_debug) return;\n            console.log(`::MSG-RELAY (${level}):: ${msg}`);\n        }\n\n        //fn to mock an incoming message to the relay (as if incoming from a different level) - useful for testing\n        //funcitonality tied to bound listeners in applications that use the relay\n        function _localSendMsg( msgType, data, componentId=null){\n            data = _validateData(data);\n            if(componentId) {\n                const mtypeParts = _getMtypeInfo(msgType);\n                msgType = _buildMsgTypeFromParts(mtypeParts.type, mtypeParts.namespace, componentId);\n            }\n\n            const msg = _getMsg( msgType, level, level,true, data );\n            msg.msgFrom = 'mock';\n            _incomingMessage( msg, {tabId: 999} );\n        }\n\n\n        function _componentSend( msgType, data={}, componentName=null, forceLocal=false ){\n            const mtypeParts = _getMtypeInfo(msgType);\n            const componentFilter = COMPONENT_NAME_ALL_PREFIX + (componentName || '');\n            msgType = _buildMsgTypeFromParts(mtypeParts.type, mtypeParts.namespace, componentFilter);\n            if(level === LEVELS.iframe || forceLocal){\n                return _localSendMsg( msgType, data);\n            }\n            _sendDown(msgType, LEVELS.iframe);\n        }\n\n        function _componentOn (msgType, componentName, cb, isOnce=false){\n            if(![LEVELS.page, LEVELS.content, LEVELS.iframe_shim].includes(level)){\n                throw new ChromeExtensionMessageRelayError(\"Cannot bind component on listeners in this level\");\n            }\n            const targetComponent = COMPONENT_NAME_ALL_PREFIX + componentName;\n            _bind(msgType, cb, [LEVELS.iframe, LEVELS.iframe_shim], isOnce, targetComponent );\n        }\n\n        function _deleteInterval(){\n            const   DELETE = 1,\n                MARK_FOR_NEXT_ROUND_DELETE = 0;\n\n            for(let msgId in _receivedMessages){\n                if(_receivedMessages[msgId] === MARK_FOR_NEXT_ROUND_DELETE){\n                    _receivedMessages[msgId] = DELETE;\n                }else{\n                    delete _receivedMessages[msgId];\n                }\n            }\n        }\n\n        //setup _receivedMessages clear interval, where we clean 2 intervals ago IDs up and mark this batches\n        //for deletion in the next interval\n        function _setupReceivedMsgCleanInterval(){\n            _receivedMsgCleanTmo = setInterval(_deleteInterval, (_receivedMsgCleanIntervalSecs * 1000) );\n        }\n        _setupReceivedMsgCleanInterval();\n\n        function _clearTmo(){\n            clearInterval(_receivedMsgCleanTmo);\n        }\n\n        function _guid(){\n            return Math.random().toString(36).substring(2, 15) +\n                Math.random().toString(36).substring(2, 15);\n        }\n\n        // =============== START OF TEST-ONLY FUNCTIONALITY ====================\n\n\n        //fn to check current env and throw error if we are NOT in test env\n\n\n\n\n\n\n\n        //fn to pass in an internal token, check that we are in a test ENV, and return reference to token\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        //create custom error class\n        function ChromeExtensionMessageRelayError(message) {\n            this.name = 'ChromeExtensionMessageRelayError';\n            this.message = message || 'Error in chrome extension message relay';\n            this.stack = (new Error()).stack;\n        }\n        ChromeExtensionMessageRelayError.prototype = Object.create(Error.prototype);\n        ChromeExtensionMessageRelayError.prototype.constructor = ChromeExtensionMessageRelayError;\n\n\n\n\n\n\n        if(level === LEVELS.content || level === LEVELS.service_worker){\n            // if specifying content level, verify this is running in an extension content or BG page to prevent spoofing\n            if(!chrome || !chrome.runtime || !chrome.runtime.id){\n                let msg = `ERROR - invalid context detected for ${level}, aborting.`;\n                throw new ChromeExtensionMessageRelayError(msg);\n            }\n        }\n\n        // =============== END OF TEST-ONLY FUNCTIONALITY ====================\n\n        // LEGACY handling -- when v2 message relay messages are passed in, they keys are now different\n        // NOTE -- this only allows v3 relays to RECIEVE v2 messages, *NOT* send messages to v2\n        const translateFromLegacyMessageFormat = (msg) => {\n            if('msg_namespace' in msg){\n                let translated = {};\n                for(let key in msg){\n                    if(key === 'msg_namespace'){\n                        translated.relayNamespace = msg.msg_namespace;\n                    }else{\n                        // convert from old camel case to snake case keys\n                        const newKey = key.replace(/_[a-z]/g, letter => `${letter.toUpperCase()}`.replace(\"_\",''));\n                        translated[newKey] = msg[key];\n                    }\n                }\n                return translated;\n            }else{\n                return msg;\n            }\n        };\n\n        if( level !== LEVELS.test ){\n            //if NOT in test ENV, bind needed listeners for appropriate ENV to wire things up\n\n            if( [LEVELS.page, LEVELS.content, LEVELS.iframe, LEVELS.iframe_shim].includes(level)){\n                //this relay is in the page, content, or iframe level so setup listener for postmessage calls\n                globals.addEventListener('message', (event) => {\n                    if(typeof event.data !== 'object') return;\n                    const msg = translateFromLegacyMessageFormat(event.data);\n\n                    // IGNORE stuff that isn't part of relay traffic, for this namespace\n                    if('relayNamespace' in msg && (msg.relayNamespace === _relayNamespace)){\n                        _incomingMessage( msg, event.source );\n                    }\n                });\n            }\n            if(level === LEVELS.content){\n                /*\n                TODO - fix for service worker\n                _log('Alerting extension of ready');\n                _contentScriptConnectPort = chrome.runtime.connect({name: namespace});\n                _contentScriptConnectPort.onMessage.addListener((msg) => {\n                    _incomingMessage(msg);\n                });\n                */\n            }\n            if(level === LEVELS.service_worker){\n                /*\n                TODO - fix for service worker\n                // every time a content script connects, mark the channel as ready!\n                chrome.runtime.onConnect.addListener((event) => {\n                    if(event.name !== namespace || event.sender.id !== chrome.runtime.id) return;\n                    _markContentScriptReady(event);\n                });\n                */\n            }\n        }\n\n        const RETURNS = {\n            levels: LEVELS,                 // Get list of available levels\n            curLevel: () => {\n                return level;\n            },\n            on: _bind,                      // Bind listener for msg event\n            onOnce: (msgTypes, cb, limitFromLevels= null) => {  // Bind listener for a single callback\n                _bind(msgTypes, cb, limitFromLevels, true);\n            },\n            off: (msgTypes) => {            // Unbind listener for msg event\n                _unbind(msgTypes);\n            },\n            componentOff: (msgTypes, componentId) => {\n                _unbind(msgTypes, componentId);\n            },\n            offAll: _unbindAll,             // Unbind all listeners at this level\n            send: _sendMsg,                 // Send message to specific level(s)\n            levelViaTabId: _levelViaTabId,  // Send message to specific level (on tabId channel only)\n            levelViaComponentId: _levelViaComponentId,\n            getLastMsgSenderInfo: () => {   // Get the sender info for last received message\n                return _lastSender;\n            },\n            getLastMsgType: () => {         // Get the msg type for last received message\n                return _lastMsg.type;\n            },\n            getLastMsg: () => {\n                return _lastMsg;\n            },\n            mockSend: _localSendMsg,        // Mock an incoming message to this level, useful for testing apps that use script\n            localSend: _localSendMsg,       // Fire event to a local listener (on this level)\n            componentSend: _componentSend,  // Fire an event to all components, or optionally named components\n            componentLocalSend: (msgType, data={}, componentName=null) => {\n                _componentSend(msgType, data, componentName, true);\n            },\n            componentOn: _componentOn,\n            componentRespond: _componentRespond,\n            clearTMO: _clearTmo,\n            registerComponentInitializedCb: (fn, nameFilter=null) => {\n                _onComponentInitializedFns.push({fn, name_filter: nameFilter});\n            },\n            setComponentEnvData: (envData) => {\n                _componentEnvData = envData;\n            },\n            setOverrideLocalComponentInit: (envData) => {\n                _componentEnvData = envData;\n                _componentLocalOverride = true;\n            },\n            getComponentEnvData: () => {\n                return _componentEnvData;\n            }\n\n        };\n\n        class Component{\n            constructor(relay, componentName, debug=false) {\n                this.enabled = true;\n                this._relay = relay;\n                this._componentName = componentName;\n                this._componentId = `${componentName}{${_guid()}}`; // format 'component{GUID}'\n                this._debug = debug;\n                this._ready = false;\n                this._initialized = false;\n                this._pendingInitCalls = [];\n                this._limitLevels = [this._relay.levels.page, this._relay.levels.content, this._relay.levels.iframe_shim];\n            }\n\n            get _initMsg(){\n                return `${COMPONENT_STATE.initEnv}.${COMPONENT_STATE_NS}`;\n            }\n\n            markReady(initEnvCallback=null){\n\n                const _ = (cb) => {\n                    if (this._ready) return;\n                    this._log(\"markReady\");\n                    if (!this.enabled) return;\n\n                    const initReturn = (envData) => {\n                        cb(envData);\n                        while (this._pendingInitCalls.length) {\n                            let call = this._pendingInitCalls.shift();\n                            call.cb(call.data);\n                        }\n                        this.off(this._initMsg); // TODO - might we wanna call this more than once???\n                    };\n                    if(_componentLocalOverride){\n                        initReturn(_componentEnvData);\n                    }else {\n                        this.on(this._initMsg, initReturn);\n                        this.send(`${COMPONENT_STATE.ready}.${COMPONENT_STATE_NS}`);\n                    }\n                    this._ready = true;\n                };\n\n                if(!initEnvCallback){\n                    return new Promise((resolve) => {\n                        _(resolve);\n                    });\n                }\n                return _(initEnvCallback);\n            }\n\n            markInitialized(){\n                if(this._initialized) return;\n                this._log(\"MarkInitialized\");\n                if(!this.enabled) return;\n                this._initialized = true;\n                this.send(`${COMPONENT_STATE.initialized}.${COMPONENT_STATE_NS}`);\n            }\n\n            _log(...args) {\n                if(!this._debug) return;\n                if(args){}\n                const items = Array.from(arguments);\n                items.unshift(`[${!this.enabled? 'DISABLED ' : ''}COMPONENT ${this._componentId}`);\n                console.warn(...items);\n            }\n\n            onOnce(msgType, cb){\n                this.on(msgType, cb, true);\n            }\n\n            on(msgType, cb, onOnce=false){\n                this._log(`>>> .on${onOnce ? 'Once' : ''}`, msgType);\n                if(!this.enabled) return;\n                this._relay.on(msgType, (data) => {\n                    this._log('>>> .on called', msgType, data);\n                    if(!this._ready && msgType !== this._initMsg){\n                        // queue calls until component is ready\n                        return this._pendingInitCalls.push({cb, data});\n                    }\n                    cb(data);\n                }, this._limitLevels, onOnce, this._componentId);\n            }\n\n            send(msgType, data= {}){\n                this._log(`>>> .send`, msgType, data);\n                if(!this.enabled) return;\n                this._relay.send(msgType, this._limitLevels, data, this._componentId);\n            }\n\n            off(msgTypes){\n                this._log(`>>> .off`, msgTypes);\n                this._relay.componentOff(msgTypes, this._componentId);\n            }\n\n            // TODO -- implement all the offAll, etc\n        }\n\n        RETURNS.newComponent = (component_name, debug=false) => {\n            if(level !== LEVELS.iframe && !_componentLocalOverride){\n                throw new ChromeExtensionMessageRelayError(\"You can only create a component in an iframe level.\");\n            }\n            let component = new Component(RETURNS, component_name, debug);\n            _components[component.id] = component;\n            return component;\n        };\n\n        return RETURNS;\n    };\n\n    if (('undefined' !== typeof module) && module.exports) {    /*REM_MODULE*/\n        //publish for node                                      /*REM_MODULE*/\n        module.exports = relay;                                 /*REM_MODULE*/\n    }else{                                                      /*REM_MODULE*/\n        //publish for browser/extension                         /*REM_MODULE*/\n        if(!('chromeExtensionMessageRelay' in globals)) {        /*REM_MODULE*/\n            globals.chromeExtensionMessageRelay = globals.chrome_extension_message_relay = relay;   /*REM_MODULE*/\n        }                                                       /*REM_MODULE*/\n    }                                                           /*REM_MODULE*/\n    return relay;\n})(typeof this !== 'undefined' ? this : (typeof window === 'undefined' ? {} : window));\n\n/* globals IRX */\n\n((IRX) => {\n\n    const LOG_ALL = false;\n\n    class LoggableClass{\n        _logging;\n        #_debugColor;\n\n        constructor(debug, recordLogs= true){\n            this._logging = {debug, classLogName: this.constructor.name, recordLogs};\n        }\n\n        getEnv(){\n            return new Promise(async (resolve) => {\n                resolve(await IRX.storeUtils.get('env') || 'production');\n            });\n        }\n\n        #debugColor(klass){\n            const possibleColors = ['#C0392B','#633974','#1A5276','#0E6655','#196F3D','#9A7D0A','#935116','#34495E',\n                '#E74C3C','#A569BD','#3498DB','#1ABC9C','#58D68D','#F39C12','#DC7633'];\n            this.#_debugColor = this.#_debugColor || possibleColors[Math.floor(Math.random()*possibleColors.length)];\n            return this.#_debugColor;\n        }\n\n        #debugConsole(){\n            if((!('LOGGER' in IRX) || !this._logging.debug) && !LOG_ALL) return;\n            const level = IRX.LOGGER.level;\n            const infoArgs = [\n                `%cIRX%c[${this._logging.classLogName}]%c${level}`,\n                'font-weight: bold; color: black; background: #f2f2f2; padding: 4px;',\n                `font-weight: bold; background: #f2f2f2; padding: 4px; color: ${this.#debugColor()};`,\n                'font-weight: bold; color: #5c5c5c; background: #f2f2f2; padding: 4px;',\n            ];\n            const allArgs = infoArgs.concat(Array.from(arguments));\n            console.log(...allArgs);\n        }\n\n        log(...args) {\n            if(this._logging.recordLogs) {\n                if ('LOGGER' in IRX) IRX.LOGGER.log(this._logging.classLogName, this._logging.debug, ...args);\n            }\n            this.#debugConsole(...args);\n        }\n\n        // for log NO STORE we just do console output but only write the FIRST argument to the store\n        logNoStore(...args){\n            if(this._logging.recordLogs) {\n                if ('LOGGER' in IRX) IRX.LOGGER.log(this._logging.classLogName, this._logging.debug, args[0]);\n            }\n            this.#debugConsole(...args);\n        }\n    }\n\n    IRX.LoggableClass = IRX.LoggableClass || LoggableClass;\n\n})(IRX);\n\n'use strict';\n/* globals IRX */\n\n((globals) => {\n    let _debug = false;\n    let _relayDebug = false;/*@DEBUG.page_relay*/\n\n    const RELAY = globals.RELAY || globals.chrome_extension_message_relay('IRX', 'page', _relayDebug);\n    globals.IS_DEV = false;\n\n    globals.LOGGER = window.LOGGER || (() => {\n\n        function _push(process, data, context = 'core') {\n            const logData = {\n                context,\n                process,\n                data\n            };\n            _log(logData);\n        }\n\n        function _log(logData){\n            if(!Array.isArray(logData)) logData = [logData];\n            RELAY.send('write.logs', RELAY.levels.iframe_shim, {logs: logData});\n        }\n\n        return {\n            log: (process, ...data) => {\n                for(let elem of data){\n                    if(elem instanceof Error) {\n                        if (globals.IS_DEV) console.error(elem);\n                        elem = elem.toString();\n                    }\n                }\n\n                if (globals.IS_DEV && _debug) console.log(`%cZI: [${process}]`, 'font-weight:bold; color: #1e46dc', ...data);\n                _push(process, data);\n            },\n            level: 'page'\n        };\n    })();\n\n    globals.RELAY = RELAY;\n})(IRX);\n"]}